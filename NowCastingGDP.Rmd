---
title: "NowCasting GDP"
author: "Minhaz Khan, Navin Chandradat, Bobak Ahmar, Vincent La"
date: "14/09/2019"
output: html_document
---
The problem that we will be tackling is the prediction of the quarters of the fiscal year. To do this, we will employ a technique called 
NowCasting, which is the prediction of the current, and near future by examining data that occur at different frequencies and with 
different lags. To begin, we'll first plot the monthly and quarterly GDPs against eachother. Next, we will fit a model based on the data 
provided and examine the correlation between different months and quarters.

```{r, fig.height=3, fig.width=5}
# load required packages
library(cansim)
library(tidyverse)
library(lubridate)
library(modelr)
library(broom)
library(astsa)
library(forecast)
library(tseries)
library(aTSA)
library(xts) # better ts objects, including quarterly series

```


```{r}
# Plot quarterly & monthly GDP 
X2raw = get_cansim_vector( c( 
  "monthly GDP (basic prices)" = "v65201210" ,
  "quarterly GDP (market prices)" = "v62305752" ) ,
    start_time = "1900-01-01" ) %>% 
  normalize_cansim_values() 
# (note correct vector code "v62305752" for quarterly GDP)
X2raw %>% filter( Date >= "2010-01-01") %>% 
  ggplot( aes( x = Date, y = VALUE, col = label ) ) +
  geom_line() + geom_point() + ylab("Chained (2012) dollars")
```


```{r}
# (note (basic prices) = (market prices) - (tax & subsidies), 
#  and that is why monthly data values are lower)

# Quartely data 
Q = X2raw %>%  
  filter( VECTOR == "v62305752" ) %>% 
  # find year & quarter
  mutate( Y = year( Date ), Q = quarter( Date ),
          index = yearqtr( Y + Q/4 ) ) %>%  
  xts( x=.$VALUE, order.by =.$index) 
# plot(Q)
# Monthly data 
M = X2raw %>%  
  filter( VECTOR == "v65201210" ) %>% 
  # find year, quarter, month, and month-in-quarter
  mutate( Y = year( Date ), Q = quarter( Date ), 
          index = yearqtr( Y + Q/4 ), 
          M = month( Date ),
          MinQ = paste( "M", M%%3, sep="" ) ) %>%  
  # spread monthly data into 3 columns one for each month-in-quarter
  pivot_wider(id_cols = index, names_from = MinQ, 
              values_from = VALUE ) %>% 
  # take lag for M0
  mutate( M0 = lag(M0) ) %>% 
  xts( x=.[,c("M0","M1","M2")], order.by =.$index) 
#plot(M$M0); plot(M)
# combine & align quarterly series with expanded monthly data
X2 = merge(Q, M, join = "inner" )
plot(X2)


```

Decomposing the Quarterly Data:
```{r}
decompose.xts <-
function (x, type = c("additive", "multiplicative"), filter = NULL) 
{
  dts <- decompose(as.ts(x), type, filter)
  dts$x <- .xts(dts$x, .index(x))
  dts$seasonal <- .xts(dts$seasonal, .index(x))
  dts$trend <- .xts(dts$trend, .index(x))
  dts$random <- .xts(dts$random, .index(x))

  with(dts,
  structure(list(x = x, seasonal = seasonal, trend = trend,
    random = if (type == "additive") x - seasonal - trend else x/seasonal/trend, 
    figure = figure, type = type), class = "decomposed.xts"))
}

plot.decomposed.xts <-
function(x, ...)
{
  xx <- x$x
  if (is.null(xx))
    xx <- with(x,
      if (type == "additive") random + trend + seasonal
      else random * trend * seasonal)
  p <- cbind(observed = xx, trend = x$trend, seasonal = x$seasonal, random = x$random)
  plot(p, main = paste("Decomposition of", x$type, "time series"), multi.panel = 4,
       yaxis.same = FALSE, major.ticks = "days", grid.ticks.on = "days", ...)
}

QDecom = decompose.xts(X2$Q)
plot(QDecom)
```
There's a clear upward trend and seasonality present.

Checking Stationarity of the Quarterly series:
```{r}
adf.test(X2$Q) #Alternative stationary not working

adf.test(as.ts(X2$Q))
```
Not Stationary, have to implement differencing


```{r}
Qdiff = diff(log(X2$Q), differences = 1)
plot(Qdiff)
adf.test(as.ts(Qdiff)) #Test not working

acf(Qdiff, na.action = na.pass, main='ACF for Differenced Series')
pacf(Qdiff, na.action = na.pass, main='PACF for Differenced Series') 
```
Data is stationary now, we test with AR 1 or 2 and MA 1 for arima model

Standard ARMA model


Arima models w/past information only -> 
      w/ past information with M0 (start of quarter forecast) + M1 (1st month nowcast) + M2 (2nd month nowcast)
```{r}
(auto.model <- auto.arima(Qdiff, seasonal = FALSE))
tsdisplay(residuals(auto.model), lag.max=45, main='(1,0,1) Model Residuals') 

model.1 <- Arima( y = X2$Q, order=c(1,1,1), include.mean = TRUE)
tsdisplay(residuals(model.1), lag.max=45, main='(1,0,1) Model Residuals')

model.2 <- Arima( y = X2$Q, order=c(1,1,1),  xreg = X2$M0, include.mean = TRUE)
tsdisplay(residuals(model.2), lag.max=45, main='(1,0,1) Model Residuals')

model.3 <- Arima( y = X2$Q, order=c(1,1,1),  xreg = X2[,c("M0","M1")], include.mean = TRUE)
tsdisplay(residuals(model.3), lag.max=45, main='(1,0,1) Model Residuals')

model.4 <- Arima( y = X2$Q, order=c(1,1,1),  xreg = X2[,c("M0","M1","M2")], include.mean = TRUE)
tsdisplay(residuals(model.4), lag.max=45, main='(1,0,1) Model Residuals')

model.1 ; model.2 ; model.3 ; model.4
```

Comparing AIC/BIC of models 
```{r}
AICS <- c(AIC(model.1),AIC(model.2),AIC(model.3),AIC(model.4))
BICS <- c(BIC(model.1),BIC(model.2),BIC(model.3),BIC(model.4))
Compare <- cbind(AICS,BICS)
Compare
```


```{r}
arima_analysis <- function(df,p,d,q, regs) {
  
  (model <- Arima( y = df, order=c(p,d,q), xreg = regs, include.mean = TRUE))
  tsdisplay(residuals(model), lag.max=45, main='Model Residuals')
  (Info_Score <- cbind(AIC(model),BIC(model)))
  model
}
```

#Improving Model with Previous Month's Data
```{r}
#HERE AND BELOW
month0 <- arima_analysis(X2$Q,1,1,1,X2$M0)
summary(month0)

cast0 = forecast::forecast(month0, xreg = X2[,c("M0")] )
plot(cast0)

```

#Improving Model with Previous 2 Month's Data
```{r}
month01 <- arima_analysis(X2$Q,1,1,1,X2[,c("M0","M1")])
summary(month01)

cast01 = forecast::forecast(month01, xreg = X2[,c("M0","M1")] )
plot(cast01)

```

#Improving Model with Previous 3 Month's Data
```{r}
month012 <- arima_analysis(X2$Q,1,1,1,X2[,c("M0","M1","M2")])
summary(month012)

cast012 = forecast::forecast(month012, xreg = X2[,c("M0","M1","M2")] )
plot(cast012)


```

```{r}
n = nrow(X2); 
nCV = 20 # number of corss validation errors
y_fe = y_fe. = rep(NA,n) # Y forecast error 

for(i in (n - nCV:1) ){
  # Increasing subsets of y,x
  yt = X2$Q[2:i]; xt = X2[2:i, c("M0","M1","M2")]  
  
  out = Arima( yt , order=c(1,1,1),  xreg = xt )
  
  # fit regression with AR(1) residuals
  Xt = cbind( 1:length(yt), xt)
  out = Arima( yt , order=c(1,1,1),  xreg = Xt )
  out = arima( yt, order = c(0,1,0), xreg = Xt[,1]) 
  
  # 1-step-ahead forecast erros using predict() function
  y_fe[i+1] = predict( out, newxreg = x[i+1] )$pred
  
  # 1-step-ahead forecast erros with hand-coded prediction 
  b0 = out$coef[2] # y mean
  b1 = out$coef[3] # regression coefficient
  phi = out$coef[1] # residual AR(1) coefficient
  y_fe.[i+1] = b0 + b1 * x[i+1] + phi * ( y[i] - b0 - b1 * x[i] )
}

# Cross-Validated Performance 

(MSPE = mean( (y - y_fe.)^2, na.rm = TRUE ))

(MAPE = mean( abs(y - y_fe.)/abs(y), na.rm = TRUE ))

```

Analyzing External Data

```{r}
LFS_2018 <- read_csv("LFS_Toronto 2018.csv")
wages <- read_csv("Wages, salaries and employers' social contributions (x 1,000).csv")
```

```{r}
# To get just the data that is seasonally adjusted
wages <- wages %>% filter(`Seasonal adjustment` == "Seasonally adjusted") %>% filter(GEO != "Outside Canada")

wages <- wages %>% mutate(REF_DATE = paste(REF_DATE, "01", sep = "-")) %>% 
  mutate(REF_DATE = ymd(REF_DATE))

wages
```



Analyzing External Data
```{r}
#Attempt at making LFS_2018 a TS
LFS_2018 %>% select(lfsstat) -> lfs_st
lfs_st
ts(lfs_st, start = c(2018, 01), frequency = 12) -> lfs_st_ts

plot(lfs_st_ts)
```


```{r}
#Attempting to make Wages and salaries a TS
wages %>% filter(GEO == "Canada") %>% 
  filter(Sector == "Wages and salaries") %>% 
  select(VALUE) -> CanWS
CanWS


ts(CanWS, start = c(1997,01), end = c(2019,6), frequency = 12) -> CanWS_ts_Monthly

#Make monthly to Quarterly
CanWS_ts_quarterly <- aggregate(CanWS_ts_Monthly, nfrequency = 4)
CanWS_ts_quarterly

CanWS_ts_Monthly <- as.xts(CanWS_ts_Monthly)
CanWS_ts_quarterly <- as.xts(CanWS_ts_quarterly)

#plot the ts 
plot(CanWS_ts_Monthly, main='CanWS_ts_Monthly')
plot(CanWS_ts_quarterly, main = 'CanWS_ts_quarterly')
plot(decompose(CanWS_ts_Monthly))
plot(decompose(CanWS_ts_quarterly))

#difference to make stationary 
# CanWS_ts_log_diff_q <- diff(log(CanWS_ts_quarterly))
# CanWS_ts_log_diff_M <- diff(log(CanWS_ts_Monthly))
# 
# plot(CanWS_ts_log_diff_q)
# plot(CanWS_ts_log_diff_M)
```
```{r}
#Compensation of employees	Time series
#Attempting to make Wages and salaries a TS
wages %>% filter(GEO == "Canada") %>% 
  filter(Sector == "Compensation of employees") %>% 
  select(VALUE) -> Compensation
Compensation


ts(Compensation, start = c(1997,01), end = c(2019,6), frequency = 12) -> Compensation_M

#Make monthly to Quarterly
Compensation_Q <- aggregate(Compensation_M, nfrequency = 4)
Compensation_Q

Compensation_M <- as.xts(Compensation_M)
Compensation_Q <- as.xts(Compensation_Q)

#plot the ts 
plot(Compensation_M, main = 'Compensation_M')
plot(Compensation_Q, main = 'Compensation_Q')
plot(decompose(Compensation_M))
plot(decompose(Compensation_Q))

#difference to make stationary 
# Comp_l_q <- diff(log(Compensation_Q))
# Comp_l_M <- diff(log(Compensation_M))
# 
# plot(Comp_l_q)
# plot(Comp_l_M)
```

```{r}
#All services-producing industries Time series
wages %>% filter(GEO == "Canada") %>% 
  filter(Sector == "All services-producing industries") %>% 
  select(VALUE) -> services_prod
services_prod


ts(services_prod, start = c(1997,01), end = c(2019,6), frequency = 12) -> services_prod_M

#Make monthly to Quarterly
services_prod_Q <- aggregate(services_prod_M, nfrequency = 4)
services_prod_Q

services_prod_M <- as.xts(services_prod_M)
services_prod_Q <- as.xts(services_prod_Q)

#plot the ts 
plot(services_prod_Q, main = 'services_prod_Q')
plot(services_prod_M, main = 'services_prod_M')
plot(decompose(services_prod_M))
plot(decompose(services_prod_Q))

#difference to make stationary 
# services_l_q <- diff(log(services_prod_M))
# services_l_M <- diff(log(services_prod_Q))
# 
# plot(services_l_q)
# plot(services_l_M)
```


```{r}
foreign_ex_rates <- read.csv("Monthly avg foreign exchange rates.csv")

#foreign_ex_rates %>% rename(REF_DATE = ï..REF_DATE) %>% 
#  mutate(REF_DATE = paste(REF_DATE, "01", sep = "-")) %>% 
 # mutate(REF_DATE = ymd(REF_DATE)) 

foreign_ex_rates_values <- foreign_ex_rates %>% 
  filter(Type.of.currency  == 
           "Canadian-Dollar Effective Exchange Rate Index (CERI), monthly average") %>% select(VALUE)


#Create Ts
ts(foreign_ex_rates_values, start = c(1997,01), end = c(2019,10), frequency = 12) -> CERI_ts

plot(CERI_ts, main = 'Canadian Effective Exchange Rate Index - Monthly AVG')

```


